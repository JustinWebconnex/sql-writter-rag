Instruction,Input,Response,Metadata
"I want to extract Giving Fuel customers with a stripe gateway






",,"Sure! Here is your code SELECT DISTINCT da.id AS customer_id, da.name AS customer_name, da.email AS customer_email
FROM wbx_data_dbt.dim_invoice di
JOIN wbx_data_dbt.dim_billing db ON di.billing_id = db.id
JOIN wbx_data_dbt.dim_account da ON di.account_id = da.id
JOIN wbx_data_dbt.dim_transaction dt ON da.id = dt.account_id
JOIN wbx_data_dbt.dim_gateway dg ON dt.gateway_id = dg.id
WHERE di.product = 'GivingFuel'
  AND dg.gateway_provider_type = 'stripe';",
"I want to extract Giving Fuel customers with a stripe gateway in 2024






",,"Sure here is your code for 2024 SELECT DISTINCT da.id AS customer_id, da.name AS customer_name, da.email AS customer_email
FROM wbx_data_dbt.dim_invoice di
JOIN wbx_data_dbt.dim_billing db ON di.billing_id = db.id
JOIN wbx_data_dbt.dim_account da ON di.account_id = da.id
JOIN wbx_data_dbt.dim_transaction dt ON da.id = dt.account_id
JOIN wbx_data_dbt.dim_gateway dg ON dt.gateway_id = dg.id
WHERE di.product = 'GivingFuel'
  AND dg.gateway_provider_type = 'stripe'
  AND dt.date_created BETWEEN '2024-01-01' AND '2024-12-31';",
How do we filter out deleted tickets in the initial raw_tickets CTE?,"WITH raw_tickets AS (
    SELECT
        id,
        property_webconnex_account_id,
        property_hubspot_owner_id,
        property_hs_pipeline_stage,
        property_createdate,
        _fivetran_deleted
    FROM hubspot.ticket
    WHERE _fivetran_deleted IS false
)
","WHERE _fivetran_deleted IS false
",This part of the code selects necessary columns from the hubspot.ticket table and filters out deleted records.
How do we ensure we are selecting the latest ticket for each account in the ranked_tickets CTE?,"ranked_tickets AS (
    SELECT
        id,
        property_webconnex_account_id,
        property_hubspot_owner_id,
        property_hs_pipeline_stage,
        ROW_NUMBER() OVER (
            PARTITION BY property_webconnex_account_id
            ORDER BY property_createdate DESC
        ) AS rn
    FROM raw_tickets
)
","ROW_NUMBER() OVER (
    PARTITION BY property_webconnex_account_id
    ORDER BY property_createdate DESC
) AS rn
","This code partitions the tickets by property_webconnex_account_id and orders them by property_createdate in descending order, assigning a row number to each."
How do we join the latest tickets with deals to get the Webconnex account ID?,"ticket_deal_wbx_id AS (
    SELECT
        t.id AS ticket_id,
        t.property_hs_pipeline_stage,
        MAX(d.property_wbx_id) AS deal_wbx_id
    FROM hubspot.ticket AS t
    LEFT JOIN hubspot.ticket_deal AS td
        ON t.id = td.ticket_id
    LEFT JOIN {{ ref('dim_deal') }} AS d
        ON td.deal_id = d.deal_id
    GROUP BY 1, 2
)
","LEFT JOIN hubspot.ticket_deal AS td
    ON t.id = td.ticket_id
LEFT JOIN {{ ref('dim_deal') }} AS d
    ON td.deal_id = d.deal_id
",This part of the code joins tickets with deals and selects the maximum Webconnex account ID for each ticket.
How do we filter the ranked_tickets to select only the latest ticket per account?,"latest_ticket AS (
    SELECT
        id,
        property_webconnex_account_id,
        property_hubspot_owner_id,
        property_hs_pipeline_stage,
        rn
    FROM ranked_tickets
    WHERE rn = 1
)
",WHERE rn = 1,This query selects only the latest ticket per account based on the row number assigned in the previous CTE.
How do we handle accounts where the Webconnex account ID is present in the tickets or deals but not in the company records?,"new_data AS (
    SELECT
        COALESCE(
            CAST(t.property_webconnex_account_id AS numeric),
            CAST(td.deal_wbx_id AS numeric),
            CASE
                WHEN
                    CAST(c.property_wbx_id AS numeric)
                    > CAST(c.property_wbx_2_0 AS numeric)
                    THEN CAST(c.property_wbx_id AS numeric)
                ELSE CAST(c.property_wbx_2_0 AS numeric)
            END
        ) AS account_id,
        am.id AS account_manager_id
    FROM latest_ticket AS t
    LEFT JOIN ticket_deal_wbx_id AS td
        ON t.id = td.ticket_id
    LEFT JOIN hubspot.ticket_company AS tc
        ON t.id = tc.ticket_id
    LEFT JOIN hubspot.company AS c
        ON tc.company_id = c.id
    LEFT JOIN hubspot.owner AS o
        ON COALESCE(t.property_hubspot_owner_id, c.property_hubspot_owner_id) = o.owner_id
    LEFT JOIN wbx_data_dbt.dim_account_managers AS am
        ON LOWER(o.first_name) = LOWER(am.first_name)
        AND LOWER(o.last_name) = LOWER(am.last_name)
    WHERE (
        t.property_hubspot_owner_id IS NOT null
        OR c.property_hubspot_owner_id IS NOT null
    )
    AND account_id IS NOT null
    AND t.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
    AND td.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
)
","COALESCE(
    CAST(t.property_webconnex_account_id AS numeric),
    CAST(td.deal_wbx_id AS numeric),
    CASE
        WHEN
            CAST(c.property_wbx_id AS numeric)
            > CAST(c.property_wbx_2_0 AS numeric)
            THEN CAST(c.property_wbx_id AS numeric)
        ELSE CAST(c.property_wbx_2_0 AS numeric)
    END
) AS account_id
",This query handles cases where the Webconnex account ID might be present in either tickets or deals but not in the company records by using a COALESCE function.
How do we join the latest tickets with the ticket-company and company tables to get the account manager information?,"LEFT JOIN hubspot.ticket_company AS tc
    ON t.id = tc.ticket_id
LEFT JOIN hubspot.company AS c
    ON tc.company_id = c.id
LEFT JOIN hubspot.owner AS o
    ON COALESCE(t.property_hubspot_owner_id, c.property_hubspot_owner_id) = o.owner_id
LEFT JOIN wbx_data_dbt.dim_account_managers AS am
    ON LOWER(o.first_name) = LOWER(am.first_name)
    AND LOWER(o.last_name) = LOWER(am.last_name)
","LEFT JOIN hubspot.ticket_company AS tc
    ON t.id = tc.ticket_id
LEFT JOIN hubspot.company AS c
    ON tc.company_id = c.id
LEFT JOIN hubspot.owner AS o
    ON COALESCE(t.property_hubspot_owner_id, c.property_hubspot_owner_id) = o.owner_id
LEFT JOIN wbx_data_dbt.dim_account_managers AS am
    ON LOWER(o.first_name) = LOWER(am.first_name)
    AND LOWER(o.last_name) = LOWER(am.last_name)
",This part of the code joins the latest tickets with the company information and account manager data.
What condition ensures that only valid account IDs and stages are included in the final dataset?,"WHERE (
    t.property_hubspot_owner_id IS NOT null
    OR c.property_hubspot_owner_id IS NOT null
)
AND account_id IS NOT null
AND t.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
AND td.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
","WHERE (
    t.property_hubspot_owner_id IS NOT null
    OR c.property_hubspot_owner_id IS NOT null
)
AND account_id IS NOT null
AND t.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
AND td.property_hs_pipeline_stage NOT IN (137720379, 33846690, 33851279)
",This query ensures that only valid account IDs and stages are included by filtering out null account IDs and specific pipeline stages.
"Retrieve the latest invoice details for each account, product, start date, and end date combination",{{ config(materialized='table') }},"WITH last_invoice AS ( SELECT i.id, ROW_NUMBER() OVER ( PARTITION BY b.account_id, b.product, i.start_date, i.end_date ORDER BY i.date_created DESC ) AS rn FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id )","This is the configuration for the dbt model, specifying that it should be materialized as a table."
"Retrieve the latest invoice details for each account, product, start date, and end date combination","WITH last_invoice AS ( SELECT i.id, ROW_NUMBER() OVER ( PARTITION BY b.account_id, b.product, i.start_date, i.end_date ORDER BY i.date_created DESC ) AS rn FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id )","SELECT i.id::int AS id, b.id AS billing_id, b.account_id, i.package_id, p.name AS product, pkg.name AS package_name, i.amount, i.date_created, i.complete_date, i.start_date, i.end_date, i.billing_date, i.status, i.forwarded_to_invoice_id, MAX(i2.id) AS forwarded_from_invoice_id FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id INNER JOIN {{ source('webconnex', 'package') }} AS pkg ON i.package_id = pkg.id LEFT JOIN {{ ref('dim_product') }} AS p ON i.product = p.url LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2 ON i2.forwarded_to_invoice_id = i.id WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1) GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14","This is the main query that retrieves the latest invoice details for each account, product, start date, and end date combination."
Retrieve invoices with a specific status,"SELECT i.id::int AS id, b.id AS billing_id, b.account_id, i.package_id, p.name AS product, pkg.name AS package_name, i.amount, i.date_created, i.complete_date, i.start_date, i.end_date, i.billing_date, i.status, i.forwarded_to_invoice_id, MAX(i2.id) AS forwarded_from_invoice_id FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id INNER JOIN {{ source('webconnex', 'package') }} AS pkg ON i.package_id = pkg.id LEFT JOIN {{ ref('dim_product') }} AS p ON i.product = p.url LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2 ON i2.forwarded_to_invoice_id = i.id WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1) AND i.status = 'paid' GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14","SELECT i.id::int AS id, b.id AS billing_id, b.account_id, i.package_id, p.name AS product, pkg.name AS package_name, i.amount, i.date_created, i.complete_date, i.start_date, i.end_date, i.billing_date, i.status, i.forwarded_to_invoice_id, MAX(i2.id) AS forwarded_from_invoice_id FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id INNER JOIN {{ source('webconnex', 'package') }} AS pkg ON i.package_id = pkg.id LEFT JOIN {{ ref('dim_product') }} AS p ON i.product = p.url LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2 ON i2.forwarded_to_invoice_id = i.id WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1) AND i.status = 'paid' GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14","This query retrieves the latest invoice details for invoices with a specific status (in this case, 'paid')."
Retrieve invoices for a specific account,"SELECT i.id::int AS id, b.id AS billing_id, b.account_id, i.package_id, p.name AS product, pkg.name AS package_name, i.amount, i.date_created, i.complete_date, i.start_date, i.end_date, i.billing_date, i.status, i.forwarded_to_invoice_id, MAX(i2.id) AS forwarded_from_invoice_id FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id INNER JOIN {{ source('webconnex', 'package') }} AS pkg ON i.package_id = pkg.id LEFT JOIN {{ ref('dim_product') }} AS p ON i.product = p.url LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2 ON i2.forwarded_to_invoice_id = i.id WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1) AND b.account_id = 123456 GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14","SELECT i.id::int AS id, b.id AS billing_id, b.account_id, i.package_id, p.name AS product, pkg.name AS package_name, i.amount, i.date_created, i.complete_date, i.start_date, i.end_date, i.billing_date, i.status, i.forwarded_to_invoice_id, MAX(i2.id) AS forwarded_from_invoice_id FROM {{ source('webconnex', 'invoice') }} AS i INNER JOIN {{ ref('dim_billing') }} AS b ON i.billing_id = b.id INNER JOIN {{ source('webconnex', 'package') }} AS pkg ON i.package_id = pkg.id LEFT JOIN {{ ref('dim_product') }} AS p ON i.product = p.url LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2 ON i2.forwarded_to_invoice_id = i.id WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1) AND b.account_id = 123456 GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14",This query retrieves the latest invoice details for a specific account (account_id = 123456).
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to get the most recent invoices per account, product, and billing period.",dim_invoice model,"WITH
last_invoice AS (
  SELECT
  i.id,
  ROW_NUMBER()
  OVER (
  PARTITION BY b.account_id, b.product, i.start_date, i.end_date
  ORDER BY i.date_created DESC
  ) AS rn
  FROM {{ source('webconnex', 'invoice') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
)
SELECT
  i.id::int AS id,
  b.id AS billing_id,
  b.account_id,
  i.package_id,
  p.name AS product,
  pkg.name AS package_name,
  i.amount,
  i.date_created,
  i.complete_date,
  i.start_date,
  i.end_date,
  i.billing_date,
  i.status,
  i.forwarded_to_invoice_id,
  MAX(i2.id) AS forwarded_from_invoice_id
FROM {{ source('webconnex', 'invoice') }} AS i
INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
INNER JOIN {{ source('webconnex', 'package') }} AS pkg
  ON i.package_id = pkg.id
LEFT JOIN {{ ref('dim_product') }} AS p
  ON i.product = p.url
LEFT JOIN {{ source('webconnex', 'invoice') }} AS i2
  ON i2.forwarded_to_invoice_id = i.id
WHERE i.id IN (SELECT id FROM last_invoice WHERE rn = 1)
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
"Generate a SQL query to filter accounts based on billing eligibility and contact name, then select specific fields.",dim_account.sql model,"WITH eligible_billing_accounts AS (
  SELECT account_id
  FROM {{ source('webconnex', 'billing') }}
  WHERE waive_invoices != 1
),
filtered_accounts AS (
  SELECT
  id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id
  FROM {{ source('webconnex', 'account') }}
  WHERE
  id IN (SELECT account_id FROM eligible_billing_accounts)
  AND NOT (
  (contact LIKE 'BONUS_%' OR contact LIKE 'PRIZE_%')
  AND date_deleted IS NOT NULL
  )
)
SELECT
  id::int AS id,
  name,
  date_created,
  date_updated,
  date_deleted,
  source,
  referral_code,
  contact,
  email,
  phone,
  organization_id::int AS organization_id
FROM filtered_accounts;","SQL, dbt, Webconnex"
Generate a SQL query to select billing items for valid account IDs and join with account details.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Generate a SQL query to select billing items for valid account IDs and join with account details.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Write a SQL query to fetch billing items linked to valid account IDs.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Create a SQL query to retrieve billing item details and join with account IDs from the dim_account table.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
"Generate a SQL script to select all fields from billing items where account IDs are valid, using a CTE.",dim_billing_item.sql model,"WITH valid_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN valid_accounts AS va ON bi.account_id = va.id;","SQL, dbt, Webconnex"
"Write a SQL query to extract billing item data with an inner join to account IDs, selecting specific fields.",dim_billing_item.sql model,"WITH account_reference AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_reference AS ar ON bi.account_id = ar.id;","SQL, dbt, Webconnex"
Create a SQL query to join billing items with valid accounts and select all relevant fields.,dim_billing_item.sql model,"WITH valid_account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN valid_account_ids AS vai ON bi.account_id = vai.id;","SQL, dbt, Webconnex"
Generate a SQL query using a CTE to filter billing items by valid account IDs.,dim_billing_item.sql model,"WITH filtered_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN filtered_accounts AS fa ON bi.account_id = fa.id;","SQL, dbt, Webconnex"
Write a SQL query to fetch billing items linked to valid account IDs.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Create a SQL query to retrieve billing item details and join with account IDs from the dim_account table.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
"Generate a SQL script to select all fields from billing items where account IDs are valid, using a CTE.",dim_billing_item.sql model,"WITH valid_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN valid_accounts AS va ON bi.account_id = va.id;","SQL, dbt, Webconnex"
"Write a SQL query to extract billing item data with an inner join to account IDs, selecting specific fields.",dim_billing_item.sql model,"WITH account_reference AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_reference AS ar ON bi.account_id = ar.id;","SQL, dbt, Webconnex"
Create a SQL query to join billing items with valid accounts and select all relevant fields.,dim_billing_item.sql model,"WITH valid_account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN valid_account_ids AS vai ON bi.account_id = vai.id;","SQL, dbt, Webconnex"
Generate a SQL query using a CTE to filter billing items by valid account IDs.,dim_billing_item.sql model,"WITH filtered_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN filtered_accounts AS fa ON bi.account_id = fa.id;","SQL, dbt, Webconnex"
Write a SQL query to fetch billing items linked to valid account IDs.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Create a SQL query to retrieve billing item details and join with account IDs from the dim_account table.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
"Generate a SQL script to select all fields from billing items where account IDs are valid, using a CTE.",dim_billing_item.sql model,"WITH valid_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN valid_accounts AS va ON bi.account_id = va.id;","SQL, dbt, Webconnex"
"Write a SQL query to extract billing item data with an inner join to account IDs, selecting specific fields.",dim_billing_item.sql model,"WITH account_reference AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_reference AS ar ON bi.account_id = ar.id;","SQL, dbt, Webconnex"
Create a SQL query to join billing items with valid accounts and select all relevant fields.,dim_billing_item.sql model,"WITH valid_account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN valid_account_ids AS vai ON bi.account_id = vai.id;","SQL, dbt, Webconnex"
Generate a SQL query using a CTE to filter billing items by valid account IDs.,dim_billing_item.sql model,"WITH filtered_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN filtered_accounts AS fa ON bi.account_id = fa.id;","SQL, dbt, Webconnex"
Write a SQL query to fetch billing items linked to valid account IDs.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Create a SQL query to retrieve billing item details and join with account IDs from the dim_account table.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
"Generate a SQL script to select all fields from billing items where account IDs are valid, using a CTE.",dim_billing_item.sql model,"WITH valid_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN valid_accounts AS va ON bi.account_id = va.id;","SQL, dbt, Webconnex"
"Write a SQL query to extract billing item data with an inner join to account IDs, selecting specific fields.",dim_billing_item.sql model,"WITH account_reference AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_reference AS ar ON bi.account_id = ar.id;","SQL, dbt, Webconnex"
Create a SQL query to join billing items with valid accounts and select all relevant fields.,dim_billing_item.sql model,"WITH valid_account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN valid_account_ids AS vai ON bi.account_id = vai.id;","SQL, dbt, Webconnex"
Generate a SQL query using a CTE to filter billing items by valid account IDs.,dim_billing_item.sql model,"WITH filtered_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN filtered_accounts AS fa ON bi.account_id = fa.id;","SQL, dbt, Webconnex"
Write a SQL query to fetch billing items linked to valid account IDs.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
Create a SQL query to retrieve billing item details and join with account IDs from the dim_account table.,dim_billing_item.sql model,"WITH account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN account_ids AS a ON bi.account_id = a.id;","SQL, dbt, Webconnex"
"Generate a SQL script to select all fields from billing items where account IDs are valid, using a CTE.",dim_billing_item.sql model,"WITH valid_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN valid_accounts AS va ON bi.account_id = va.id;","SQL, dbt, Webconnex"
"Write a SQL query to extract billing item data with an inner join to account IDs, selecting specific fields.",dim_billing_item.sql model,"WITH account_reference AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN account_reference AS ar ON bi.account_id = ar.id;","SQL, dbt, Webconnex"
Create a SQL query to join billing items with valid accounts and select all relevant fields.,dim_billing_item.sql model,"WITH valid_account_ids AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
JOIN valid_account_ids AS vai ON bi.account_id = vai.id;","SQL, dbt, Webconnex"
Generate a SQL query using a CTE to filter billing items by valid account IDs.,dim_billing_item.sql model,"WITH filtered_accounts AS (
  SELECT id
  FROM {{ ref('dim_account') }}
)
SELECT
  bi.id::int AS id,
  bi.account_id::int AS account_id,
  bi.billing_id::int AS billing_id,
  bi.page_id::int AS page_id,
  bi.subject_type,
  bi.subject_id,
  bi.exclude_from_invoicing,
  bi.pricing_type,
  bi.quantity,
  bi.total,
  bi.currency,
  bi.date_created,
  bi.date_updated
FROM {{ source('webconnex', 'billing_item') }} AS bi
INNER JOIN filtered_accounts AS fa ON bi.account_id = fa.id;","SQL, dbt, Webconnex"
Explain the purpose of the code,{{ config(materialized='table') }},This is a dbt configuration that specifies the model should be materialized as a table.,This is a dbt model that creates an aggregate table for cohort signup account revenue.
Explain the purpose of the temp CTE,"WITH temp AS (SELECT cs.account_id, cs.account_name, cs.account_manager_id, cs.account_manager_name, cs.organization_id, cs.product, cs.currency, cs.revenue_cohort_date AS cohort_date, cs.digital_marketing_spend_monthly, date_part(MONTH, date_trunc('month', cs.date_created)) AS month, date_part(YEAR, date_trunc('year', cs.date_created)) AS year, date_trunc('month', cs.date_created) AS date, SUM(cs.total) AS monthly_total FROM {{ ref('cohort_signup_account_revenue') }} AS cs WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay') GROUP BY cs.account_id, cs.account_name, cs.account_manager_id, cs.account_manager_name, cs.organization_id, cs.product, cs.currency, DATE_TRUNC('year', cs.date_created), DATE_TRUNC('month', cs.date_created), cs.revenue_cohort_date, cs.digital_marketing_spend_monthly),","The temp CTE selects various columns from the cohort_signup_account_revenue model and calculates the monthly total revenue for each account, product, currency, and cohort date combination. It filters the data based on specific sources and groups the results accordingly.",This CTE provides the base data for further transformations in the query.
Explain the purpose of the x CTE,"x AS (SELECT r.account_id, r.product, r.account_name, r.account_manager_id, r.account_manager_name, r.cohort_date, r.organization_id, r.currency, 0 AS monthly_total, 0 AS ytd_total, MIN(r.date) AS min_date, MAX(r.date) AS max_date FROM temp AS r GROUP BY 1, 2, 3, 4, 5, 6, 7, 8),","The x CTE selects various columns from the temp CTE and calculates the minimum and maximum dates for each account, product, and currency combination. It sets the monthly_total and ytd_total columns to 0 for further processing.","This CTE is used to generate a set of unique combinations of account, product, and currency, along with their associated metadata."
Explain the purpose of the account_dates CTE,"account_dates AS (SELECT random() AS id, x.account_id, d.full_date, x.min_date, x.cohort_date, x.account_name, x.account_manager_id, x.account_manager_name, x.product, x.organization_id, x.currency FROM x CROSS JOIN {{ ref('dim_dates') }} AS d WHERE d.full_date >= x.min_date AND d.month_day_number = 1 AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'),","The account_dates CTE performs a cross join between the x CTE and the dim_dates model to generate a row for each account, currency, cohort date, and month combination. It filters the dates based on the minimum date from the x CTE and includes only the first day of each month up to the current date plus one month.","This CTE creates a set of rows representing all possible combinations of accounts, dates, and associated metadata for further processing."
Explain the purpose of the base CTE,"base AS (SELECT a.id, a.account_id, a.account_name, a.account_manager_id, a.account_manager_name, a.organization_id, a.product, a.currency, cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month, cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year, a.full_date AS date, a.cohort_date, r.digital_marketing_spend_monthly, COALESCE(r.monthly_total, 0) AS monthly_total FROM account_dates AS a LEFT JOIN temp AS r ON a.account_id = r.account_id AND a.full_date = r.date AND a.product = r.product AND a.currency = r.currency),","The base CTE performs a left join between the account_dates CTE and the temp CTE to retrieve the digital marketing spend and monthly total for each account, date, product, and currency combination. It casts the month and year columns as SMALLINT and selects various columns from the joined data.",This CTE combines the data from the account_dates and temp CTEs to create a base dataset with all the necessary columns for further aggregations.
Generate a SQL query to create a temporary table with aggregated cohort signup account revenue.,dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Create a SQL query to generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Write a SQL query to cross join dates with accounts to create 'account_dates' table.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a SQL query to create a base table by joining account_dates and temp.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Create a SQL query to calculate the monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Write a SQL query to select final results by joining base and py_monthly tables.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
Generate a SQL query to create a temporary table with aggregated cohort signup account revenue.,dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Create a SQL query to generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Write a SQL query to cross join dates with accounts to create 'account_dates' table.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a SQL query to create a base table by joining account_dates and temp.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Create a SQL query to calculate the monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Write a SQL query to select final results by joining base and py_monthly tables.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
Generate a SQL query to create a temporary table with aggregated cohort signup account revenue.,dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Create a SQL query to generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Write a SQL query to cross join dates with accounts to create 'account_dates' table.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a SQL query to create a base table by joining account_dates and temp.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Create a SQL query to calculate the monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Write a SQL query to select final results by joining base and py_monthly tables.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
Generate a SQL query to create a temporary table with aggregated cohort signup account revenue.,dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Create a SQL query to generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Write a SQL query to cross join dates with accounts to create 'account_dates' table.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a SQL query to create a base table by joining account_dates and temp.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Create a SQL query to calculate the monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Write a SQL query to select final results by joining base and py_monthly tables.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
Generate a SQL query to create a temporary table with aggregated cohort signup account revenue.,dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Create a SQL query to generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Write a SQL query to cross join dates with accounts to create 'account_dates' table.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a SQL query to create a base table by joining account_dates and temp.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Create a SQL query to calculate the monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Write a SQL query to select final results by joining base and py_monthly tables.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
"Create a temporary table aggregating cohort signup account revenue with account, currency, and cohort_date granularity.",dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Create 'account_dates' table by cross joining dates with accounts.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a base table by joining account_dates and temp tables.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Calculate monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Join base and py_monthly tables to select the final results.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
"Create a temporary table aggregating cohort signup account revenue with account, currency, and cohort_date granularity.",dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Create 'account_dates' table by cross joining dates with accounts.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a base table by joining account_dates and temp tables.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Calculate monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Join base and py_monthly tables to select the final results.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
"Create a temporary table aggregating cohort signup account revenue with account, currency, and cohort_date granularity.",dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Create 'account_dates' table by cross joining dates with accounts.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a base table by joining account_dates and temp tables.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Calculate monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Join base and py_monthly tables to select the final results.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
"Create a temporary table aggregating cohort signup account revenue with account, currency, and cohort_date granularity.",dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Create 'account_dates' table by cross joining dates with accounts.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a base table by joining account_dates and temp tables.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Calculate monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Join base and py_monthly tables to select the final results.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
"Create a temporary table aggregating cohort signup account revenue with account, currency, and cohort_date granularity.",dim_cohort_signup_revenue.sql model,"WITH temp AS (
  SELECT
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  cs.revenue_cohort_date AS cohort_date,
  cs.digital_marketing_spend_monthly,
  date_part(MONTH, date_trunc('month', cs.date_created)) AS month,
  date_part(YEAR, date_trunc('year', cs.date_created)) AS year,
  date_trunc('month', cs.date_created) AS date,
  SUM(cs.total) AS monthly_total
  FROM {{ ref('cohort_signup_account_revenue') }} AS cs
  WHERE cs.source IN ('invoice', 'app_fee_adyen', 'app_fee_wepay')
  GROUP BY
  cs.account_id,
  cs.account_name,
  cs.account_manager_id,
  cs.account_manager_name,
  cs.organization_id,
  cs.product,
  cs.currency,
  DATE_TRUNC('year', cs.date_created),
  DATE_TRUNC('month', cs.date_created),
  cs.revenue_cohort_date,
  cs.digital_marketing_spend_monthly
);","SQL, dbt, Webconnex"
Generate a table 'x' with the minimum and maximum dates from the temp CTE.,dim_cohort_signup_revenue.sql model,"WITH x AS (
  SELECT
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency,
  0 AS monthly_total,
  0 AS ytd_total,
  MIN(r.date) AS min_date,
  MAX(r.date) AS max_date
  FROM temp AS r
  GROUP BY
  r.account_id,
  r.product,
  r.account_name,
  r.account_manager_id,
  r.account_manager_name,
  r.cohort_date,
  r.organization_id,
  r.currency
);","SQL, dbt, Webconnex"
Create 'account_dates' table by cross joining dates with accounts.,dim_cohort_signup_revenue.sql model,"WITH account_dates AS (
  SELECT
  random() AS id,
  x.account_id,
  d.full_date,
  x.min_date,
  x.cohort_date,
  x.account_name,
  x.account_manager_id,
  x.account_manager_name,
  x.product,
  x.organization_id,
  x.currency
  FROM x
  CROSS JOIN {{ ref('dim_dates') }} AS d
  WHERE
  d.full_date >= x.min_date
  AND d.month_day_number = 1
  AND d.full_date <= CURRENT_DATE + INTERVAL '1 month'
);","SQL, dbt, Webconnex"
Generate a base table by joining account_dates and temp tables.,dim_cohort_signup_revenue.sql model,"WITH base AS (
  SELECT
  a.id,
  a.account_id,
  a.account_name,
  a.account_manager_id,
  a.account_manager_name,
  a.organization_id,
  a.product,
  a.currency,
  cast(extract(MONTH FROM a.full_date) AS SMALLINT) AS month,
  cast(extract(YEAR FROM a.full_date) AS SMALLINT) AS year,
  a.full_date AS date,
  a.cohort_date,
  r.digital_marketing_spend_monthly,
  COALESCE(r.monthly_total, 0) AS monthly_total
  FROM account_dates AS a
  LEFT JOIN temp AS r
  ON a.account_id = r.account_id
  AND a.full_date = r.date
  AND a.product = r.product
  AND a.currency = r.currency
);","SQL, dbt, Webconnex"
Calculate monthly and aggregate totals for the previous year.,dim_cohort_signup_revenue.sql model,"WITH py_monthly AS (
  SELECT
  account_id,
  year,
  month,
  product,
  currency,
  date AS trailing_date,
  COALESCE(monthly_total, 0) AS trailing_total,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency, month ORDER BY date ROWS UNBOUNDED PRECEDING) AS monthly_aggregate,
  SUM(monthly_total) OVER (PARTITION BY account_id, product, currency ORDER BY date ROWS UNBOUNDED PRECEDING) AS aggregate_total
  FROM base
);","SQL, dbt, Webconnex"
Join base and py_monthly tables to select the final results.,dim_cohort_signup_revenue.sql model,"SELECT
  b.*,
  m.trailing_date,
  m.aggregate_total,
  COALESCE(m.trailing_total, 0) AS trailing_total,
  COALESCE(m.monthly_aggregate, 0) AS monthly_aggregate
FROM base AS b
LEFT JOIN py_monthly AS m
ON b.account_id = m.account_id
AND b.product = m.product
AND b.currency = m.currency
AND b.month = m.month
AND b.year = m.year + 1;","SQL, dbt, Webconnex"
Calculate the maximum digital marketing spend and account signups monthly for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  MAX(digital_marketing_spend_monthly) AS digital_marketing_spend_monthly,
  MAX(account_signups_monthly) :: INT AS account_signups_monthly
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Count the cumulative customers for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  CAST(COUNT(DISTINCT account_id) AS numeric) :: INT AS cum_cus_count
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate converted signups percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(cum_cus_count / MAX(account_signups_monthly)::numeric * 100) :: INT AS converted_signups
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the customer acquisition cost (CAC) for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(MAX(digital_marketing_spend_monthly) / cum_cus_count) :: INT AS cac
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the payback percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(SUM(total) / MAX(digital_marketing_spend_monthly) * 100) :: INT AS payback
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate cumulative customer count for each month since cohort_date for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"{% set now = modules.datetime.datetime.now() %}
{% set reference_dt = modules.datetime.datetime(2019, 1, 1) %}
{% set num_months = ( (now.year - reference_dt.year)*12 + now.month - reference_dt.month ) %}

SELECT
  product,
  cohort_date,
  {% for month_offset in range(0, num_months) %}
  COUNT(DISTINCT
  CASE
  WHEN DATEDIFF('month', cohort_date, date_created) <= {{ month_offset }}
  AND DATEADD('month', {{ month_offset }}, cohort_date) <= DATE_TRUNC('month', GETDATE())
  THEN account_id
  END
  ) :: INT AS ccc_at_month_{{ month_offset + 1 }}{% if not loop.last %},
  {% endif %}
  {% endfor %}
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the maximum digital marketing spend and account signups monthly for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  MAX(digital_marketing_spend_monthly) AS digital_marketing_spend_monthly,
  MAX(account_signups_monthly) :: INT AS account_signups_monthly
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Count the cumulative customers for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  CAST(COUNT(DISTINCT account_id) AS numeric) :: INT AS cum_cus_count
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate converted signups percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(cum_cus_count / MAX(account_signups_monthly)::numeric * 100) :: INT AS converted_signups
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the customer acquisition cost (CAC) for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(MAX(digital_marketing_spend_monthly) / cum_cus_count) :: INT AS cac
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the payback percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(SUM(total) / MAX(digital_marketing_spend_monthly) * 100) :: INT AS payback
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate cumulative customer count for each month since cohort_date for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"{% set now = modules.datetime.datetime.now() %}
{% set reference_dt = modules.datetime.datetime(2019, 1, 1) %}
{% set num_months = ( (now.year - reference_dt.year)*12 + now.month - reference_dt.month ) %}

SELECT
  product,
  cohort_date,
  {% for month_offset in range(0, num_months) %}
  COUNT(DISTINCT
  CASE
  WHEN DATEDIFF('month', cohort_date, date_created) <= {{ month_offset }}
  AND DATEADD('month', {{ month_offset }}, cohort_date) <= DATE_TRUNC('month', GETDATE())
  THEN account_id
  END
  ) :: INT AS ccc_at_month_{{ month_offset + 1 }}{% if not loop.last %},
  {% endif %}
  {% endfor %}
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the maximum digital marketing spend and account signups monthly for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  MAX(digital_marketing_spend_monthly) AS digital_marketing_spend_monthly,
  MAX(account_signups_monthly) :: INT AS account_signups_monthly
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Count the cumulative customers for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  CAST(COUNT(DISTINCT account_id) AS numeric) :: INT AS cum_cus_count
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate converted signups percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(cum_cus_count / MAX(account_signups_monthly)::numeric * 100) :: INT AS converted_signups
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the customer acquisition cost (CAC) for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(MAX(digital_marketing_spend_monthly) / cum_cus_count) :: INT AS cac
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the payback percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(SUM(total) / MAX(digital_marketing_spend_monthly) * 100) :: INT AS payback
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate cumulative customer count for each month since cohort_date for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"{% set now = modules.datetime.datetime.now() %}
{% set reference_dt = modules.datetime.datetime(2019, 1, 1) %}
{% set num_months = ( (now.year - reference_dt.year)*12 + now.month - reference_dt.month ) %}

SELECT
  product,
  cohort_date,
  {% for month_offset in range(0, num_months) %}
  COUNT(DISTINCT
  CASE
  WHEN DATEDIFF('month', cohort_date, date_created) <= {{ month_offset }}
  AND DATEADD('month', {{ month_offset }}, cohort_date) <= DATE_TRUNC('month', GETDATE())
  THEN account_id
  END
  ) :: INT AS ccc_at_month_{{ month_offset + 1 }}{% if not loop.last %},
  {% endif %}
  {% endfor %}
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the maximum digital marketing spend and account signups monthly for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  MAX(digital_marketing_spend_monthly) AS digital_marketing_spend_monthly,
  MAX(account_signups_monthly) :: INT AS account_signups_monthly
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Count the cumulative customers for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  CAST(COUNT(DISTINCT account_id) AS numeric) :: INT AS cum_cus_count
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate converted signups percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(cum_cus_count / MAX(account_signups_monthly)::numeric * 100) :: INT AS converted_signups
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the customer acquisition cost (CAC) for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(MAX(digital_marketing_spend_monthly) / cum_cus_count) :: INT AS cac
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the payback percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(SUM(total) / MAX(digital_marketing_spend_monthly) * 100) :: INT AS payback
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate cumulative customer count for each month since cohort_date for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"{% set now = modules.datetime.datetime.now() %}
{% set reference_dt = modules.datetime.datetime(2019, 1, 1) %}
{% set num_months = ( (now.year - reference_dt.year)*12 + now.month - reference_dt.month ) %}

SELECT
  product,
  cohort_date,
  {% for month_offset in range(0, num_months) %}
  COUNT(DISTINCT
  CASE
  WHEN DATEDIFF('month', cohort_date, date_created) <= {{ month_offset }}
  AND DATEADD('month', {{ month_offset }}, cohort_date) <= DATE_TRUNC('month', GETDATE())
  THEN account_id
  END
  ) :: INT AS ccc_at_month_{{ month_offset + 1 }}{% if not loop.last %},
  {% endif %}
  {% endfor %}
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the maximum digital marketing spend and account signups monthly for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  MAX(digital_marketing_spend_monthly) AS digital_marketing_spend_monthly,
  MAX(account_signups_monthly) :: INT AS account_signups_monthly
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Count the cumulative customers for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  CAST(COUNT(DISTINCT account_id) AS numeric) :: INT AS cum_cus_count
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate converted signups percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(cum_cus_count / MAX(account_signups_monthly)::numeric * 100) :: INT AS converted_signups
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the customer acquisition cost (CAC) for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(MAX(digital_marketing_spend_monthly) / cum_cus_count) :: INT AS cac
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate the payback percentage for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"SELECT
  product,
  cohort_date,
  ROUND(SUM(total) / MAX(digital_marketing_spend_monthly) * 100) :: INT AS payback
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Calculate cumulative customer count for each month since cohort_date for each product and cohort_date.,dim_cohort_signup_account_revenue.sql model,"{% set now = modules.datetime.datetime.now() %}
{% set reference_dt = modules.datetime.datetime(2019, 1, 1) %}
{% set num_months = ( (now.year - reference_dt.year)*12 + now.month - reference_dt.month ) %}

SELECT
  product,
  cohort_date,
  {% for month_offset in range(0, num_months) %}
  COUNT(DISTINCT
  CASE
  WHEN DATEDIFF('month', cohort_date, date_created) <= {{ month_offset }}
  AND DATEADD('month', {{ month_offset }}, cohort_date) <= DATE_TRUNC('month', GETDATE())
  THEN account_id
  END
  ) :: INT AS ccc_at_month_{{ month_offset + 1 }}{% if not loop.last %},
  {% endif %}
  {% endfor %}
FROM {{ ref('cohort_signup_account_revenue') }}
WHERE
  attribution_type NOT IN ('outside sales', 'enterprise')
  AND organization_id = 1
  AND cohort_date > '2019-01-01'
GROUP BY product, cohort_date;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Create a CTE to calculate the year-to-date Adyen transaction volume for each account.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Extract the gateway creation date, account ID, and account name from the Adyen transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the year-to-date volume of Adyen transactions for each account, considering only settled and refunded transactions.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  a.id AS account_id,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  a.id
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
Filter Adyen transactions to include only captures and refunds that are either settled or refunded.,dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  pe.status,
  pe.type,
  pe.amount
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Group Adyen transactions by gateway creation date, account ID, and account name to summarize the YTD volume.",dim_adyen_transactions.sql model,"WITH adyen_transactions AS (
  SELECT
  ma.created_at AS gateway_date_created,
  a.id AS account_id,
  a.name AS account_name,
  SUM(CASE
  WHEN pe.status = 'REFUNDED' THEN -pe.amount
  WHEN pe.status = 'SETTLED' THEN pe.amount
  ELSE 0
  END) AS ytd_adyen_volume
  FROM
  {{ source('payments', 'payment_event') }} AS pe
  INNER JOIN
  {{ source('payments', 'merchant_account') }} AS ma
  ON pe.merchantaccountid = ma.id
  INNER JOIN
  {{ ref('dim_account') }} AS a
  ON SPLIT_PART(pe.tenant_id, 'webconnex-', 2)::VARCHAR = a.id
  WHERE
  pe.status IN ('REFUNDED', 'SETTLED')
  AND pe.type IN ('CAPTURE', 'REFUND')
  GROUP BY
  ma.created_at,
  a.id,
  a.name
)
SELECT * FROM adyen_transactions;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for TicketSpice.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'TicketSpice' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_ts.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for RegFox.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'RegFox' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_rf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Google ads for GivingFuel.",dim_digital_marketing.sql model,"SELECT
  date,
  'Google' AS source,
  'PPS' AS type,
  'GivingFuel' AS product,
  ROUND(SUM(cost_micros) / 1000000.0, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  ROUND((SUM(conversions))::numeric, 2) AS conversions
FROM google_ads_gf.account_stats
GROUP BY 1;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Bing ads for various products based on account_id.",dim_digital_marketing.sql model,"SELECT
  date,
  'Bing' AS source,
  'PPS' AS type,
  CASE
  WHEN account_id = 180753652 THEN 'TicketSpice'
  WHEN account_id = 180753653 THEN 'RegFox'
  WHEN account_id = 180753654 THEN 'GivingFuel'
  WHEN account_id = 180753655 THEN 'RedPodium'
  END AS product,
  (SUM(spend))::decimal(10, 2) AS spend,
  SUM(impressions)::int AS impressions,
  SUM(clicks)::int AS clicks,
  SUM(conversions) AS conversions
FROM bing_ads.account_impression_performance_daily_report
WHERE account_id IN (180753652, 180753653, 180753654, 180753655)
GROUP BY 1, 2, 3, 4;","SQL, dbt, Webconnex"
"Calculate the total spend, impressions, clicks, and conversions for Meta ads based on account_id.",dim_digital_marketing.sql model,"SELECT
  f.date,
  'Meta' AS source,
  'PPS' AS type,
  CASE
  WHEN f.account_id = 109029029603146 THEN 'TicketSpice'
  WHEN f.account_id = 751653132580154 THEN 'RedPodium'
  WHEN f.account_id = 1152740825317175 THEN 'RegFox'
  WHEN f.account_id = 1440018596512207 THEN 'GivingFuel'
  END AS product,
  f.spend,
  f.impressions::int AS impressions,
  f.clicks::int AS clicks,
  g.signups AS conversions
FROM facebook_ads.daily_stats AS f
LEFT JOIN google_sheets.digital_marketing AS g
  ON product = g.product
  AND g.source = 'Meta'
  AND (f.date)::date = g.date;","SQL, dbt, Webconnex"
"Calculate the monthly total of orders for each account, product, and currency.",dim_ttm_revenue.sql model,"WITH monthly AS (
  SELECT
  account_id,
  product_name,
  currency,
  DATE_TRUNC('month', pp_date)::date AS pp_month,
  SUM(pp_total) AS monthly_total
  FROM {{ ref('pp_orders') }}
  WHERE
  pp_status = 3
  AND pp_date IS NOT NULL
  GROUP BY 1, 2, 3, 4
);","SQL, dbt, Webconnex"
Generate a distinct list of months between January 2019 and the current date.,dim_ttm_revenue.sql model,"WITH distinct_dates AS (
  SELECT DISTINCT DATE_TRUNC('month', full_date)::date AS date_month
  FROM {{ ref('dim_dates') }}
  WHERE full_date BETWEEN '2019-01-01' AND CURRENT_DATE
);","SQL, dbt, Webconnex"
"Create a cross join of accounts, products, and currencies to ensure all combinations are included.",dim_ttm_revenue.sql model,"WITH cross_joined_accounts AS (
  SELECT
  account_id,
  product_name,
  currency
  FROM monthly
  GROUP BY 1, 2, 3
);","SQL, dbt, Webconnex"
Select the monthly totals from the 'monthly' CTE.,dim_ttm_revenue.sql model,"WITH monthly_totals AS (
  SELECT
  account_id,
  product_name,
  currency,
  pp_month,
  monthly_total
  FROM monthly
);","SQL, dbt, Webconnex"
Cross join the distinct months with the cross_joined_accounts and left join the monthly_totals.,dim_ttm_revenue.sql model,"WITH all_months AS (
  SELECT
  d.date_month,
  m.account_id,
  m.product_name,
  m.currency,
  mt.monthly_total
  FROM
  distinct_dates AS d
  CROSS JOIN
  cross_joined_accounts AS m
  LEFT JOIN
  monthly_totals AS mt ON
  m.account_id = mt.account_id
  AND m.product_name = mt.product_name
  AND m.currency = mt.currency
  AND d.date_month = mt.pp_month
);","SQL, dbt, Webconnex"
"Calculate the trailing twelve months (TTM) total for each account, product, and currency.",dim_ttm_revenue.sql model,"SELECT *
FROM (
  SELECT
  account_id,
  product_name,
  currency,
  date_month,
  SUM(
  monthly_total) OVER (
  PARTITION BY account_id, product_name, currency
  ORDER BY date_month
  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS ttm_total
  FROM all_months
  GROUP BY 1, 2, 3, 4, monthly_total
) AS x
WHERE ttm_total IS NOT NULL;","SQL, dbt, Webconnex"
"Calculate the monthly total of orders for each account, product, and currency.",dim_ttm_revenue.sql model,"WITH monthly AS (
  SELECT
  account_id,
  product_name,
  currency,
  DATE_TRUNC('month', pp_date)::date AS pp_month,
  SUM(pp_total) AS monthly_total
  FROM {{ ref('pp_orders') }}
  WHERE
  pp_status = 3
  AND pp_date IS NOT NULL
  GROUP BY 1, 2, 3, 4
);","SQL, dbt, Webconnex"
Generate a distinct list of months between January 2019 and the current date.,dim_ttm_revenue.sql model,"WITH distinct_dates AS (
  SELECT DISTINCT DATE_TRUNC('month', full_date)::date AS date_month
  FROM {{ ref('dim_dates') }}
  WHERE full_date BETWEEN '2019-01-01' AND CURRENT_DATE
);","SQL, dbt, Webconnex"
"Create a cross join of accounts, products, and currencies to ensure all combinations are included.",dim_ttm_revenue.sql model,"WITH cross_joined_accounts AS (
  SELECT
  account_id,
  product_name,
  currency
  FROM monthly
  GROUP BY 1, 2, 3
);","SQL, dbt, Webconnex"
Select the monthly totals from the 'monthly' CTE.,dim_ttm_revenue.sql model,"WITH monthly_totals AS (
  SELECT
  account_id,
  product_name,
  currency,
  pp_month,
  monthly_total
  FROM monthly
);","SQL, dbt, Webconnex"
Cross join the distinct months with the cross_joined_accounts and left join the monthly_totals.,dim_ttm_revenue.sql model,"WITH all_months AS (
  SELECT
  d.date_month,
  m.account_id,
  m.product_name,
  m.currency,
  mt.monthly_total
  FROM
  distinct_dates AS d
  CROSS JOIN
  cross_joined_accounts AS m
  LEFT JOIN
  monthly_totals AS mt ON
  m.account_id = mt.account_id
  AND m.product_name = mt.product_name
  AND m.currency = mt.currency
  AND d.date_month = mt.pp_month
);","SQL, dbt, Webconnex"
"Calculate the trailing twelve months (TTM) total for each account, product, and currency.",dim_ttm_revenue.sql model,"SELECT *
FROM (
  SELECT
  account_id,
  product_name,
  currency,
  date_month,
  SUM(
  monthly_total) OVER (
  PARTITION BY account_id, product_name, currency
  ORDER BY date_month
  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS ttm_total
  FROM all_months
  GROUP BY 1, 2, 3, 4, monthly_total
) AS x
WHERE ttm_total IS NOT NULL;","SQL, dbt, Webconnex"
"Calculate the monthly total of orders for each account, product, and currency.",dim_ttm_revenue.sql model,"WITH monthly AS (
  SELECT
  account_id,
  product_name,
  currency,
  DATE_TRUNC('month', pp_date)::date AS pp_month,
  SUM(pp_total) AS monthly_total
  FROM {{ ref('pp_orders') }}
  WHERE
  pp_status = 3
  AND pp_date IS NOT NULL
  GROUP BY 1, 2, 3, 4
);","SQL, dbt, Webconnex"
Generate a distinct list of months between January 2019 and the current date.,dim_ttm_revenue.sql model,"WITH distinct_dates AS (
  SELECT DISTINCT DATE_TRUNC('month', full_date)::date AS date_month
  FROM {{ ref('dim_dates') }}
  WHERE full_date BETWEEN '2019-01-01' AND CURRENT_DATE
);","SQL, dbt, Webconnex"
"Create a cross join of accounts, products, and currencies to ensure all combinations are included.",dim_ttm_revenue.sql model,"WITH cross_joined_accounts AS (
  SELECT
  account_id,
  product_name,
  currency
  FROM monthly
  GROUP BY 1, 2, 3
);","SQL, dbt, Webconnex"
Select the monthly totals from the 'monthly' CTE.,dim_ttm_revenue.sql model,"WITH monthly_totals AS (
  SELECT
  account_id,
  product_name,
  currency,
  pp_month,
  monthly_total
  FROM monthly
);","SQL, dbt, Webconnex"
Cross join the distinct months with the cross_joined_accounts and left join the monthly_totals.,dim_ttm_revenue.sql model,"WITH all_months AS (
  SELECT
  d.date_month,
  m.account_id,
  m.product_name,
  m.currency,
  mt.monthly_total
  FROM
  distinct_dates AS d
  CROSS JOIN
  cross_joined_accounts AS m
  LEFT JOIN
  monthly_totals AS mt ON
  m.account_id = mt.account_id
  AND m.product_name = mt.product_name
  AND m.currency = mt.currency
  AND d.date_month = mt.pp_month
);","SQL, dbt, Webconnex"
"Calculate the trailing twelve months (TTM) total for each account, product, and currency.",dim_ttm_revenue.sql model,"SELECT *
FROM (
  SELECT
  account_id,
  product_name,
  currency,
  date_month,
  SUM(
  monthly_total) OVER (
  PARTITION BY account_id, product_name, currency
  ORDER BY date_month
  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS ttm_total
  FROM all_months
  GROUP BY 1, 2, 3, 4, monthly_total
) AS x
WHERE ttm_total IS NOT NULL;","SQL, dbt, Webconnex"
"Calculate the monthly total of orders for each account, product, and currency.",dim_ttm_revenue.sql model,"WITH monthly AS (
  SELECT
  account_id,
  product_name,
  currency,
  DATE_TRUNC('month', pp_date)::date AS pp_month,
  SUM(pp_total) AS monthly_total
  FROM {{ ref('pp_orders') }}
  WHERE
  pp_status = 3
  AND pp_date IS NOT NULL
  GROUP BY 1, 2, 3, 4
);","SQL, dbt, Webconnex"
Generate a distinct list of months between January 2019 and the current date.,dim_ttm_revenue.sql model,"WITH distinct_dates AS (
  SELECT DISTINCT DATE_TRUNC('month', full_date)::date AS date_month
  FROM {{ ref('dim_dates') }}
  WHERE full_date BETWEEN '2019-01-01' AND CURRENT_DATE
);","SQL, dbt, Webconnex"
"Create a cross join of accounts, products, and currencies to ensure all combinations are included.",dim_ttm_revenue.sql model,"WITH cross_joined_accounts AS (
  SELECT
  account_id,
  product_name,
  currency
  FROM monthly
  GROUP BY 1, 2, 3
);","SQL, dbt, Webconnex"
Select the monthly totals from the 'monthly' CTE.,dim_ttm_revenue.sql model,"WITH monthly_totals AS (
  SELECT
  account_id,
  product_name,
  currency,
  pp_month,
  monthly_total
  FROM monthly
);","SQL, dbt, Webconnex"
Cross join the distinct months with the cross_joined_accounts and left join the monthly_totals.,dim_ttm_revenue.sql model,"WITH all_months AS (
  SELECT
  d.date_month,
  m.account_id,
  m.product_name,
  m.currency,
  mt.monthly_total
  FROM
  distinct_dates AS d
  CROSS JOIN
  cross_joined_accounts AS m
  LEFT JOIN
  monthly_totals AS mt ON
  m.account_id = mt.account_id
  AND m.product_name = mt.product_name
  AND m.currency = mt.currency
  AND d.date_month = mt.pp_month
);","SQL, dbt, Webconnex"
"Calculate the trailing twelve months (TTM) total for each account, product, and currency.",dim_ttm_revenue.sql model,"SELECT *
FROM (
  SELECT
  account_id,
  product_name,
  currency,
  date_month,
  SUM(
  monthly_total) OVER (
  PARTITION BY account_id, product_name, currency
  ORDER BY date_month
  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS ttm_total
  FROM all_months
  GROUP BY 1, 2, 3, 4, monthly_total
) AS x
WHERE ttm_total IS NOT NULL;","SQL, dbt, Webconnex"
"Calculate the monthly total of orders for each account, product, and currency.",dim_ttm_revenue.sql model,"WITH monthly AS (
  SELECT
  account_id,
  product_name,
  currency,
  DATE_TRUNC('month', pp_date)::date AS pp_month,
  SUM(pp_total) AS monthly_total
  FROM {{ ref('pp_orders') }}
  WHERE
  pp_status = 3
  AND pp_date IS NOT NULL
  GROUP BY 1, 2, 3, 4
);","SQL, dbt, Webconnex"
Generate a distinct list of months between January 2019 and the current date.,dim_ttm_revenue.sql model,"WITH distinct_dates AS (
  SELECT DISTINCT DATE_TRUNC('month', full_date)::date AS date_month
  FROM {{ ref('dim_dates') }}
  WHERE full_date BETWEEN '2019-01-01' AND CURRENT_DATE
);","SQL, dbt, Webconnex"
"Create a cross join of accounts, products, and currencies to ensure all combinations are included.",dim_ttm_revenue.sql model,"WITH cross_joined_accounts AS (
  SELECT
  account_id,
  product_name,
  currency
  FROM monthly
  GROUP BY 1, 2, 3
);","SQL, dbt, Webconnex"
Select the monthly totals from the 'monthly' CTE.,dim_ttm_revenue.sql model,"WITH monthly_totals AS (
  SELECT
  account_id,
  product_name,
  currency,
  pp_month,
  monthly_total
  FROM monthly
);","SQL, dbt, Webconnex"
Cross join the distinct months with the cross_joined_accounts and left join the monthly_totals.,dim_ttm_revenue.sql model,"WITH all_months AS (
  SELECT
  d.date_month,
  m.account_id,
  m.product_name,
  m.currency,
  mt.monthly_total
  FROM
  distinct_dates AS d
  CROSS JOIN
  cross_joined_accounts AS m
  LEFT JOIN
  monthly_totals AS mt ON
  m.account_id = mt.account_id
  AND m.product_name = mt.product_name
  AND m.currency = mt.currency
  AND d.date_month = mt.pp_month
);","SQL, dbt, Webconnex"
"Calculate the trailing twelve months (TTM) total for each account, product, and currency.",dim_ttm_revenue.sql model,"SELECT *
FROM (
  SELECT
  account_id,
  product_name,
  currency,
  date_month,
  SUM(
  monthly_total) OVER (
  PARTITION BY account_id, product_name, currency
  ORDER BY date_month
  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS ttm_total
  FROM all_months
  GROUP BY 1, 2, 3, 4, monthly_total
) AS x
WHERE ttm_total IS NOT NULL;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'email' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'email' AS feature,
  month::date AS month,
  product,
  account_id,
  'Automation' AS sub_type,
  emails_sent AS item_count,
  emails_sent_rev::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  0.00 AS activation_revenue
  FROM {{ ref('email_automation') }}
)","SQL, dbt, Webconnex"
Join the calculated monthly feature revenues with account details and account manager details.,dim_feature_revenue.sql model,"SELECT
  b.*,
  a.name AS account_name,
  am.first_name || ' ' || am.last_name AS account_manager,
  it.industry
FROM base AS b
LEFT JOIN {{ ref('dim_account') }} AS a
  ON b.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON b.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
LEFT JOIN wbx_data_persistent.industry_tam AS it
  ON a.id = it.account_id;","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'domain' feature including plan revenue.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'domain' AS feature,
  DATE_TRUNC('month', i.date_created)::date AS month,
  b.product,
  b.account_id,
  'Custom' AS sub_type,
  0 AS item_count,
  0::decimal(10, 2) AS item_revenue,
  (SUM(i.total) / 100)::decimal(10, 2) AS plan_revenue,
  0::decimal(10, 2) AS activation_revenue
  FROM {{ ref('dim_billing_item') }} AS i
  INNER JOIN {{ ref('dim_billing') }} AS b
  ON i.billing_id = b.id
  WHERE i.pricing_type = 39
  GROUP BY 1, 2, 3, 4
)","SQL, dbt, Webconnex"
Calculate the monthly revenue for 'sms' feature including item count and revenues.,dim_feature_revenue.sql model,"WITH base AS (
  SELECT
  'sms' AS feature,
  month::date AS month,
  product,
  account_id,
  sms_plan_type AS sub_type,
  sms_sent AS item_count,
  sms_revenue::decimal(10, 2) AS item_revenue,
  plan_revenue::decimal(10, 2) AS plan_revenue,
  activation_revenue::decimal(10, 2) AS activation_revenue
  FROM {{ ref('sms_plans') }}
)","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"
Retrieve the most recent invoice information for each billing ID.,dim_transaction_summary.sql model,"WITH invoice_info AS (
  SELECT *
  FROM (SELECT
  i.id,
  i.billing_id,
  i.package_id,
  i.start_date,
  i.package_name,
  i.end_date,
  DATE_TRUNC('month', i.complete_date) AS invoice_complete_month,
  DATE_TRUNC('month', i.date_created) AS invoice_month,
  ROW_NUMBER() OVER (PARTITION BY b.id ORDER BY i.id DESC) AS rn
  FROM wbx_data_dbt.dim_invoice AS i
  LEFT JOIN wbx_data_dbt.dim_billing AS b
  ON i.billing_id = b.id
  WHERE i.status = 7
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, b.id) AS x
  WHERE rn = 1
)","SQL, dbt, Webconnex"
Count the distinct ticket and registrant IDs for each transaction.,dim_transaction_summary.sql model,"WITH item AS (
  SELECT
  transaction_id,
  COUNT(DISTINCT item.ticket_id) AS ticket_count,
  COUNT(DISTINCT item.registrant_id) AS registrant_count
  FROM {{ source('webconnex', 'item') }}
  WHERE COALESCE(item.registrant_id, item.ticket_id) IS NOT NULL
  GROUP BY 1
)","SQL, dbt, Webconnex"
"Join transaction data with account, account manager, form, gateway, billing, invoice, and item details.",dim_transaction_summary.sql model,"SELECT
  a.organization_id,
  a.id AS account_id,
  am.first_name || ' ' || am.last_name AS account_manager,
  f.product,
  i.package_id,
  i.package_name,
  a.name AS account_name,
  g.type AS gateway_type,
  CASE
  WHEN t.date_created < '2023-02-01 00:00:00' THEN NULL
  WHEN g.type IN ('wepay', 'wave') THEN 'wepay'
  WHEN LOWER(g.type) = 'adyen' THEN 'adyen'
  WHEN bi.id IS NOT NULL THEN 'custom'
  ELSE 'free'
  END AS volume_type,
  t.currency,
  t.status,
  t.source_type,
  t.payment_method,
  b.waive_invoices,
  DATE_TRUNC('month', t.date_created)::date AS transaction_month,
  i.invoice_month,
  i.invoice_complete_month,
  MAX(t.date_created) AS last_transaction_date,
  SUM(CASE
  WHEN t.transaction_type = 1 THEN t.amount
  WHEN t.transaction_type = 2 THEN -t.amount
  ELSE 0
  END) AS transaction_amount,
  COUNT(*) AS transaction_count,
  SUM(item.ticket_count) AS ticket_count,
  SUM(item.registrant_count) AS registrant_count
FROM {{ ref('dim_transaction') }} AS t
INNER JOIN {{ ref('dim_account') }} AS a
  ON t.account_id = a.id
LEFT JOIN {{ ref('dim_account_managers_account') }} AS ama
  ON t.account_id = ama.account_id
LEFT JOIN {{ ref('dim_account_managers') }} AS am
  ON ama.account_manager_id = am.id
INNER JOIN {{ ref('dim_form') }} AS f
  ON t.form_id = f.id
INNER JOIN {{ ref('dim_gateway') }} AS g
  ON t.gateway_id = g.id
INNER JOIN {{ ref('dim_billing') }} AS b
  ON f.account_id = b.account_id
  AND f.product = b.product
LEFT JOIN invoice_info AS i
  ON b.id = i.billing_id
  AND t.date_created >= i.start_date AND t.date_created <= i.end_date
LEFT JOIN {{ ref('dim_billing_item') }} AS bi
  ON bi.subject_type = 'transaction'
  AND t.id = bi.subject_id
  AND bi.pricing_type = 4
  AND bi.date_created >= '2023-02-01 00:00:00'
LEFT JOIN item
  ON t.id = item.transaction_id
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17","SQL, dbt, Webconnex"